asect 0x00
table:            #######  выигрышные адреса 
dc 0, 1, 2
dc 3, 4, 5
dc 6, 7, 8
dc 0, 3, 6
dc 1, 4, 7
dc 2, 5, 8
dc 0, 4, 8
dc 2, 4, 6
asect  0xf0
arr:              ####### память под массив
ds 9
addr_in: ds 1     ####### input
addr_out: ds 1    ####### output
asect 0x18        ####### программа начинается с адреса 0x18

ldi r0, table
ldi r1, 24
init_table:       ####### загрузка таблицы в ОЗУ
	ldc r0, r2
	st r0, r2
	inc r0
	dec r1
	bnz init_table  ####### загрузка до тех пор, пока счётчик не обнулится

ldi r0, addr_in
ld r0, r0        ####### считать номер кнопки с адреса addr_in
ldi r1, arr
add r1, r0       ####### arr = f0;   f0 + num_button = fx  <- адрес элемента массива по номеру кнопки
ld r0, r2
if 
	tst r2
is z             ####### если элемент массива = 0 (пустая клетка)
	ldi r2, 3
	st r0, r2    ####### сохранить в адрес массива тройку (крестик)
else
	br final     ####### иначе - этот случай возможен только если клетка уже занята. Данное условие необходимо на всякий случай
fi

if
	ldi r0, 0xf4 ####### адрес центрального элемента массива (центр игрового поля)
	ld r0, r1
	tst r1       ####### если центр - пустая клетка
is eq
	ldi r2, 1
	st r0, r2    ####### сохранить нолик в центре
	br final     ####### перейти в конец программы
fi
##################################################################################################################

ldi r0, table    ####### указатель на элемент таблицы (в данный момент на начало)
ldi r1, 24       ####### счётчик

update_nolik:   
ldi r3, 0		 ####### Сумма 
push r1          ####### пока что выкину счётчик в стэк и освобожу регистр

ldi r2, arr      ####### сохранить в регистр начало массива
ld r0, r1        ####### загрузить указателя на элемент таблицы его значение (первый клетка победной комбинации)
add r1, r2       ####### arr = f0;   f0 + num_cell = fx  <- адрес элемента массива по номеру клетки
ld r2, r1        ####### загрузить в r1 значение по адресу r2, а именно значение элемента массива

add r1, r3       ####### добавить в сумму значение элемента массива (+0 or +1 or +3)

inc r0           ####### сделать шаг по таблице

ldi r2, arr      ####### аналогично со вторым элементом победной комбинации
ld r0, r1
add r1, r2
ld r2, r1

add r1, r3

inc r0

ldi r2, arr      ####### аналогично с третьим элементом победной комбинации
ld r0, r1
add r1, r2
ld r2, r1

add r1, r3

inc r0	

push r0		     ####### кинуть в стэк указатель на следующую победную комбинацию

if
	ldi r0, 9   
	cmp r3, r0   ####### если сумма = 9 (3 + 3 + 3)
is eq
	pop r0
	pop r1
	br final     ####### данная ситуация обрабатывается в Logisim
fi

if 
	ldi r0, 6    
	cmp r3, r0   ####### если сумма = 6 (3 + 0 + 3)
is eq, or
	ldi r0, 2    ####### если сумма = 2 (0 + 1 + 1)
	cmp r3, r0
is eq
	then
	pop r0       ####### достать из стека указатель на новую победную комбинацию
	pop r1       ####### достать из стека счётчик             
				 ####### освобождение стэка необходимо, ведь если сейчас может победить крестик и бот его блокирует, то перемещение по таблице больше не нужно. 
	             ####### сейчас нужно найти пустую клетку, сохранить в массив, переместиться в final и отдать в output
	dec r0       ####### возврат на прошлую победную комбинацию
	push r0      ####### я думал, что мне не хватит регистров, но я только заметил, что я не использую r3   ヽ(°□° )ノ
	ld r0, r0    ####### какая клетка в победной комбинации
	ldi r2, arr  
	add r0, r2   ###### какой клетке соответсвует элемент массива
	pop r0
	if
		ld r2, r1
		tst r1
	is eq        ###### если элемент массива = 0
		ldi r1, 1
		st r2, r1
		move r2, r0
		br final  ####### пустая клетка найдена, сохранить в массив, перейти в final
	fi
	dec r0
	push r0
	ld r0, r0
	ldi r2, arr
	add r0, r2
	pop r0
	if           ####### Аналогично, если предыдущая клетка была не пустая
		ld r2, r1
		tst r1
	is eq
		ldi r1, 1
		st r2, r1
		move r2, r0
		br final
	fi
	dec r0
	push r0
	ld r0, r0
	ldi r2, arr
	add r0, r2
	pop r0
	if
		ld r2, r1
		tst r1
	is eq                  ####### Эта клетка пустая, если программа дошла до сюда, но проверку на пустоту есть
		ldi r1, 1
		st r2, r1
		move r2, r0
		br final
	fi
fi
ldi r2, 3              ####### загрузим в r2 - 3
pop r0                 ####### сейчас у нас в стэке следующая победная комбинация и счётчик, поэтому достать
pop r1
sub r2, r1             ####### счётчик показывает, сколько элементов таблицы проверить осталось. Проверели 3, поэтому    счётчик-=3
neg r1
bnz update_nolik       ####### если счётчик = 0 - не переходить на update_nolik 
	

ldi r0, arr
algoritm:             ####### ищем пустую клетку и ставим туда нолик, ведь на этой метке можно оказаться только 
				      ####### если бот не защитился от крестиков и он не может сейчас победить 
if 
	ldi r2, 0xf9      ####### 0xf9 = последний элемент массива + 1
	cmp r0, r2
is eq
	br final
fi
if 
	ld r0, r1
	tst r1
is eq
	ldi r2, 1
	st r0, r2
	ldi r1, arr
	sub r1, r0
	neg r0
	br final
else
	inc r0
	br algoritm
fi


final:
ldi r3, addr_out    
st r3, r0        #######сохраняем значение r0 по адреса addr_out 
halt
end